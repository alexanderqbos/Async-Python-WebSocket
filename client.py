#!/usr/bin/python3

import asyncio
import sys
import random
import string

#
# PURPOSE:
# Generate new key for the new message being sent
#
# RETURN/SIDE EFFECTS:
# returns a new 8 character key generated by randomly
#
def gen_new_key():
    return ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))

# NOTE: Key is now a global value, it can now be handled in the async methods and is
# tracked since the methods are apart of the gather function in the main().
key = ''

#
# PURPOSE:
# initialise the connection variables and error checks the commandline arguments
#
# RETURN/SIDE EFFECTS:
# returns 3 values, host, port, and an initial key
#
# NOTES:
# The key is used to test_key against the server response, if it is blank then this key
# is used in send_client_message()
#
def initConnection():
    global key
    if len(sys.argv) < 4:
        print(sys.argv[0] + '<Host Ip> <port> <initial-key>')
        sys.exit(0)
    host = str(sys.argv[1])
    port = int(sys.argv[2])
    key = str(sys.argv[3])
    while(len(key) < 8):
        print('Error: key too short!\n>', end='')
        key = str(input())
    return  host, port

#
# PURPOSE:
# On a five second interval we will look for, from the server a new message
# if the key is still a blank it will not show the same message again.
#
# PARAMETERS:
# host - The ip/url of the connection
# port - port address of the connection
# key - current global key used to retrieve messages (should give blank message)
#
# NOTES:
# utility function for the send and get, some logic of the original get is 
# abstracted to here
async def get_by_key(host, port, key):
    reader, writer = await asyncio.open_connection(host, port)
    writer.write(b'GET' + key.encode("utf-8") + b"\n")
    data = await reader.readline()
    data = data.decode('utf-8')
    data = data.strip()
    return data;
#
# PURPOSE:
# On a five second interval we will look for, from the server a new message
# if the key is still a blank it will not show the same message again.
#
# PARAMETERS:
# host - The ip/url of the connection
# port - port address of the connection
#
# NOTES:
# Uses the get_by_key method to get blank key value from server messages.
async def test_key(host, port):
    global key
    while True:
        data = await get_by_key(host, port, key)
        if(data == ''):
            key = key
            await asyncio.sleep(5)
        else:
            async with asyncio.Lock():
                print(f'Received: {data[2:-8]}')
            key = data[-8:]

#
# PURPOSE:
# loops indefinatly while client is running and will create a thread for blocking
# input() function using run_in_executor. We do a while loop to make sure we have
# the most updated key to pass to the PUT message.
#
# PARAMETERS:
# host - The ip/url of the connection
# port - port address of the connection
#
# NOTES:
# Uses the get_by_key method to get blank key value from server messages.
async def send_user_message(host, port):
    global key
    while True:
        message = await loop.run_in_executor(None, input)
        data = await get_by_key(host, port, key)
        while(data != ''):
            print(f'Received: {data[2:-8]}')
            key = data[-8:]
            data = await get_by_key(host, port, key)
        reader, writer = await asyncio.open_connection(host, port)
        async with asyncio.Lock():
            message = 'PUT' + key + message + gen_new_key() + '\n'
            message = message.encode('utf-8')
            writer.write(message)

#
# PURPOSE:
# Wrapping async function for gathering the async function send_user_message and test_key.
# Defines the host and port passed in the command line.
#
# NOTES:
# try except for the keyboard interrupt while awaiting gather.
#
async def main():
    host, port = initConnection()
    try:
        await asyncio.gather(send_user_message(host, port), test_key(host, port))
    except KeyboardInterrupt:
        pass

# NOTE: Changed the run for the main fuction from asyncio.run(), could not get input
# to run_in_executor with get_running_loop() so I use get_event_loop and run_until_complete()
loop = asyncio.get_event_loop()
loop.run_until_complete(main())
loop.close()
